<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WebXR AR Camera Feed with Movement Controls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      canvas {
        display: block;
      }

      #overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 999;
      }

      #ar-ui {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      .control-panel {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        /* Adjust for exact centering */
        background-color: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        padding: 15px;
        pointer-events: auto;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(2, 44px);
        gap: 8px;
        width: auto;
        max-width: 90%;
        height: auto;
        max-height: 100px;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(2, 44px);
        z-index: 1001;
      }

      .button-wrapper {
        width: 100%;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      button {
        padding: 0 10px;
        background-color: rgba(255, 255, 255, 0.8);
        border: none;
        border-radius: 5px;
        font-weight: bold;
        cursor: pointer;
        font-size: 14px;
        min-width: 90px;
        width: 100%;
        height: 100%;
        line-height: 1;
      }

      button:active {
        background-color: rgba(200, 200, 200, 0.8);
      }

      #arButton {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 20px;
        border: none;
        border-radius: 5px;
        background-color: #4285f4;
        color: white;
        font-weight: bold;
        cursor: pointer;
        z-index: 999;
        width: auto;
        height: auto;
      }

      /* Optional: add some styling to make specific buttons stand out */
      #moveUp {
        background-color: rgba(200, 255, 200, 0.9);
      }

      #moveDown {
        background-color: rgba(255, 200, 200, 0.9);
      }

      #readyButton {
        position: fixed;
        top: 125px;
        /* You can adjust the value to position it further down or up */
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background-color: #4285f4;
        color: white;
        font-weight: bold;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        z-index: 999;
        height: 50px;
      }

      #readyButton:active {
        background-color: rgba(200, 200, 200, 0.8);
      }

      #crosshair {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 30px;
        height: 30px;
        pointer-events: none;
        z-index: 1000;
      }

      #crosshair::before,
      #crosshair::after {
        content: "";
        position: absolute;
        background: rgba(0, 255, 0, 0.8);
      }

      #crosshair::before {
        width: 2px;
        height: 100%;
        left: 50%;
        transform: translateX(-50%);
      }

      #crosshair::after {
        height: 2px;
        width: 100%;
        top: 50%;
        transform: translateY(-50%);
      }

      #attackButton {
        background-color: rgba(255, 0, 0, 0.7);
        color: white;
      }

      #counterDisplay {
        position: fixed;
        top: 20px;
        left: 20px;
        color: white;
        font-size: 1.2em;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 1001;
        text-shadow: 0 0 2px black;
      }

      /* AR session adjustments */
      .xr-overlay #crosshair,
      .xr-overlay #counterDisplay {
        transform: translateZ(0);
        backface-visibility: hidden;
        will-change: transform;
      }

      #gameInfo {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 15px;
        border-radius: 5px;
        font-size: 14px;
        z-index: 999;
        text-align: center;
      }
    </style>
  </head>

  <body>
    <div id="gameInfo">Loading game info...</div>

    <div id="overlay">
      <div id="ar-ui">
        <div id="crosshair"></div>
      </div>
      <div class="control-panel">
        <button id="readyButton">Ready</button>
        <div class="button-wrapper">
          <button id="moveLeft">Left</button>
        </div>
        <div class="button-wrapper">
          <button id="moveForward">Forward</button>
        </div>
        <div class="button-wrapper">
          <button id="moveRight">Right</button>
        </div>
        <div class="button-wrapper">
          <button id="moveDown">Down</button>
        </div>
        <div class="button-wrapper">
          <button id="moveBackward">Back</button>
        </div>
        <div class="button-wrapper">
          <button id="moveUp">Up</button>
        </div>
      </div>
    </div>

    <button id="arButton">Start AR</button>

    <script src="https://cdn.jsdelivr.net/npm/webxr-polyfill"></script>
    <script>
      const polyfill = new WebXRPolyfill();
    </script>

    <!-- Add Socket.IO client -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

    <script type="module">
      import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
      import { HolographicDragon } from "./HolographicDragon.js";

      // Parse URL parameters to get gameId and playerId
      const urlParams = new URLSearchParams(window.location.search);
      const gameId = urlParams.get("gameId");
      const playerId = urlParams.get("playerId"); // Store playerId globally for easier access

      // Display game info
      const gameInfoElement = document.getElementById("gameInfo");
      if (gameId && playerId) {
        gameInfoElement.textContent = `Game ID: ${gameId.substring(
          0,
          8
        )}... | Player ID: ${playerId.substring(0, 8)}...`;
      } else {
        gameInfoElement.textContent = "Missing game or player information!";
        gameInfoElement.style.backgroundColor = "rgba(255, 0, 0, 0.7)";
      }

      // Set up Socket.IO connection
      const socket = io();

      // Check connection status
      socket.on("connect", () => {
        console.log("Connected to server with socket ID:", socket.id);
        if (gameId && playerId) {
          console.log(
            `ðŸš€ Emitting reconnectPlayer for game ${gameId}, player ${playerId} using socket ${socket.id}`
          );
          // Tell the server to associate this new socket with the existing player and join the room
          socket.emit("reconnectPlayer", { gameId, playerId });
        } else {
          console.error(
            "âŒ Cannot reconnect: Missing gameId or playerId on calibration page load."
          );
          gameInfoElement.textContent =
            "Error: Missing game/player info. Cannot join game room.";
          gameInfoElement.style.backgroundColor = "rgba(255, 0, 0, 0.7)";
          // Consider disabling UI or redirecting
        }
      });

      socket.on("connect_error", (error) => {
        console.error("Connection error:", error);
        gameInfoElement.textContent = "Connection error! Please refresh.";
        gameInfoElement.style.backgroundColor = "rgba(255, 0, 0, 0.7)";
      });

      let scene, camera, renderer, dragon;

      // Set up the basic scene
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Lighting
      const light = new THREE.HemisphereLight(0xffffff, 0x444444);
      scene.add(light);

      // Add directional light for better visibility
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 5, 0);
      scene.add(directionalLight);

      // Raycasting logic
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      // Attack function
      function checkIntersection() {
        if (!dragon || !dragon.model) return false; // Ensure dragon is loaded
        mouse.set(0, 0); // Center of the screen
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(dragon.model, true); // Check descendants

        if (intersects.length > 0) {
          console.log("HIT!", intersects[0].distance);
          return true;
        }
        return false;
      }

      // Add dragon model
      async function loadDragon() {
        const dragonInstance = new HolographicDragon();
        dragon = await dragonInstance.load();
        if (dragon && dragon.model) {
          dragon.model.position.set(0, -1, -10);
          scene.add(dragon.model);
        } else {
          console.error("Failed to load dragon model correctly.");
        }
      }

      // AR Button functionality
      const arButton = document.getElementById("arButton");

      // Check if XR is supported
      if ("xr" in navigator) {
        navigator.xr.isSessionSupported("immersive-ar").then((supported) => {
          if (supported) {
            arButton.textContent = "Start AR";
            arButton.disabled = false;
          } else {
            arButton.textContent = "AR Not Supported";
            arButton.disabled = true;
          }
        });
      } else {
        arButton.textContent = "XR Not Supported";
        arButton.disabled = true;
      }

      function startAR() {
        const sessionInit = {
          optionalFeatures: ["dom-overlay"],
          domOverlay: { root: document.getElementById("overlay") },
        };
        navigator.xr
          .requestSession("immersive-ar", sessionInit)
          .then(onSessionStarted);
      }

      function onSessionStarted(session) {
        session.addEventListener("end", onSessionEnded);
        renderer.xr.setReferenceSpaceType("local");
        renderer.xr.setSession(session);
        arButton.textContent = "Stop AR";
        arButton.style.display = "none"; // Hide the AR button in AR mode
        document.body.classList.add("xr-overlay"); // Add class for AR specific styles
      }

      function onSessionEnded() {
        arButton.textContent = "Start AR";
        arButton.style.display = "block"; // Show the AR button when AR ends
        document.body.classList.remove("xr-overlay"); // Remove class
      }

      arButton.addEventListener("click", () => {
        if (renderer.xr.getSession() === null) {
          startAR();
        } else {
          renderer.xr.getSession().end();
        }
      });

      // Add movement controls
      const moveDistance = 0.5; // movement distance per button press

      document.getElementById("moveForward").addEventListener("click", () => {
        if (dragon && dragon.model) dragon.model.position.z -= moveDistance;
      });

      document.getElementById("moveBackward").addEventListener("click", () => {
        if (dragon && dragon.model) dragon.model.position.z += moveDistance;
      });

      document.getElementById("moveLeft").addEventListener("click", () => {
        if (dragon && dragon.model) dragon.model.position.x -= moveDistance;
      });

      document.getElementById("moveRight").addEventListener("click", () => {
        if (dragon && dragon.model) dragon.model.position.x += moveDistance;
      });

      document.getElementById("moveUp").addEventListener("click", () => {
        if (dragon && dragon.model) dragon.model.position.y += moveDistance;
      });

      document.getElementById("moveDown").addEventListener("click", () => {
        if (dragon && dragon.model) dragon.model.position.y -= moveDistance;
      });

      // Ready button event listener
      document.getElementById("readyButton").addEventListener("click", () => {
        if (!gameId || !playerId) {
          alert("Missing game or player information!");
          return;
        }
        if (!dragon || !dragon.model) {
          alert("Dragon model not loaded yet!");
          return;
        }

        // Store the sphere position locally - this is your dragon's position
        const dragonPosition = {
          x: dragon.model.position.x,
          y: dragon.model.position.y,
          z: dragon.model.position.z,
        };

        // Store dragon position in localStorage for later use
        localStorage.setItem(
          `dragon_position_${gameId}_${playerId}`,
          JSON.stringify(dragonPosition)
        );

        // Notify server player is ready
        socket.emit("playerReady", { gameId, playerId });

        // Update UI to show player is ready
        const readyButton = document.getElementById("readyButton");
        readyButton.textContent = "Waiting for others...";
        readyButton.disabled = true;
        readyButton.style.backgroundColor = "#888888";
      });

      // --- Game State Management ---
      // Initialize gameState on the window object
      window.gameState = {
        localPlayers: [], // Array to hold player data { id, name, isSelf, isDead, health, position?, mesh? }
        bossHealth: 0,
        gameActive: false,
      };

      // Set up all socket event handlers at the same level
      socket.on("gameStarted", (data) => {
        // Hide all existing UI elements (calibration controls)
        const controlPanel = document.querySelector(".control-panel");
        if (controlPanel) controlPanel.style.display = "none";
        const readyButton = document.getElementById("readyButton");
        if (readyButton) readyButton.style.display = "none";

        // Update game info to show we're in active game mode
        const gameInfoElement = document.getElementById("gameInfo");
        gameInfoElement.textContent = `Game Active! Boss Health: ${data.bossHealth}`;
        gameInfoElement.style.backgroundColor = "rgba(0, 128, 0, 0.7)"; // Green background

        // Initialize local players array and game state
        initializeLocalPlayers(data.players); // This now populates window.gameState.localPlayers
        window.gameState.bossHealth = data.bossHealth;
        window.gameState.gameActive = true;

        // Create a game UI overlay with attack button and health display
        createGameUI(); // This will now read initial health from gameState
      });

      // Dragon attack handler
      socket.on("dragonAttacked", (data) => {
        console.log("DRAGON ATTACKING!");
        
        // Only process if game is active and gameState is initialized
        if (!window.gameState || !window.gameState.gameActive) return;

        const targetPlayerIds = data.targetPlayerIds;

        // Check if current player is targeted
        if (targetPlayerIds.includes(playerId)) {
          // Find the current player in the localPlayers array
          const currentPlayer = window.gameState.localPlayers.find(
            (p) => p.id === playerId
          );

          if (!currentPlayer || currentPlayer.isDead) return; // Player not found or already dead
          
          console.log("damage before:"+currentPlayer.health);
          
          // --- MODIFICATION START ---
          // Calculate new health based on the value stored in the data structure
          const damage = 5; // Example damage value
          const newHealth = Math.max(0, currentPlayer.health - damage);

          console.log("damage after:"+currentPlayer.health);

          // Update the health in the data structure
          currentPlayer.health = newHealth;
          // --- MODIFICATION END ---

          // Update health display UI
          const healthDisplay = document.getElementById("healthDisplay");
          if (healthDisplay) {
            healthDisplay.textContent = `Your Health: ${newHealth}`;
          }

          // Visual feedback for being hit
          document.body.style.backgroundColor = "rgba(255, 0, 0, 0.3)";
          setTimeout(() => {
            document.body.style.backgroundColor = "transparent";
          }, 300);

          // Check if player died
          if (newHealth <= 0) {
            currentPlayer.isDead = true; // Mark as dead in the data structure

            // Notify server
            socket.emit("playerDied", { gameId, playerId });

            // Update UI to show death
            if (healthDisplay) {
              healthDisplay.textContent = "YOU DIED!";
              healthDisplay.style.color = "red";
            }

            const attackButton = document.getElementById("attackButton");
            if (attackButton) {
              attackButton.disabled = true;
              attackButton.textContent = "DEFEATED";
              attackButton.style.backgroundColor = "#888888";
            }
          }
        }
      });

      // Player death handler
      socket.on("playerDied", (data) => {
        // Only process if game is active and gameState is initialized
        if (!window.gameState || !window.gameState.gameActive) return;

        // Find the player in local array
        const localPlayers = window.gameState.localPlayers;
        const playerIndex = localPlayers.findIndex((p) => p.id === data.playerId);

        if (playerIndex !== -1) {
          // Mark player as dead in the data structure
          localPlayers[playerIndex].isDead = true;
          localPlayers[playerIndex].health = 0; // Ensure health is 0

          // Update visual representation if it's another player
          if (data.playerId !== playerId) {
            updatePlayerVisualForDeath(data.playerId);
          }
        }
      });

      // Boss health update handler
      socket.on("bossHealthUpdated", (data) => {
        // Only process if game is active and gameState is initialized
        if (!window.gameState || !window.gameState.gameActive) return;

        window.gameState.bossHealth = data.health;
        const gameInfoElement = document.getElementById("gameInfo");
        if (gameInfoElement) {
          gameInfoElement.textContent = `Game Active! Boss Health: ${data.health}`;
        }
      });

      // Game end handler
      socket.on("gameEnded", (data) => {
        // Update game state
        if (window.gameState) {
          window.gameState.gameActive = false;
        }

        // Show game outcome UI
        showGameEndUI(data);
      });

      // Helper functions to organize code
      function createGameUI() {
        // Remove existing game UI if present
        const existingGameUI = document.getElementById("gameUI");
        if (existingGameUI) {
          existingGameUI.remove();
        }

        const gameUI = document.createElement("div");
        gameUI.id = "gameUI";

        // Find the current player's initial health from gameState
        const currentPlayer = window.gameState.localPlayers.find(
          (p) => p.id === playerId
        );
        const initialHealth = currentPlayer ? currentPlayer.health : 20; // Default to 20 if not found

        gameUI.innerHTML = `
        <div style="position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 10px;
                    display: flex; flex-direction: column; align-items: center; z-index: 999; pointer-events: auto;">
          <div id="healthDisplay" style="color: white; margin-bottom: 10px;">Your Health: ${initialHealth}</div>
          <button id="attackButton" style="padding: 15px 30px; background-color: #ff4444;
                  color: white; border: none; border-radius: 5px; font-weight: bold; cursor: pointer;">
            ATTACK!
          </button>
        </div>
      `;
        document.body.appendChild(gameUI);

        // Add attack button functionality
        const attackButton = document.getElementById("attackButton");
        if (attackButton) {
          attackButton.addEventListener("click", () => {
            // Check if player is dead before allowing attack
            const currentPlayer = window.gameState.localPlayers.find(
              (p) => p.id === playerId
            );
            if (!currentPlayer || currentPlayer.isDead) {
              console.log("Cannot attack, player is dead.");
              return;
            }

            let hit = checkIntersection();

            // Emit attack event to server
            socket.emit("playerAttack", {
              gameId: gameId,
              playerId: playerId,
              hit: hit,
            });

            // Show visual feedback for attack
            if (hit) {
              attackButton.style.backgroundColor = "#00ff00"; // Green for hit
              setTimeout(() => {
                if (!currentPlayer.isDead) {
                  // Only revert color if not dead
                  attackButton.style.backgroundColor = "#ff4444";
                }
              }, 300);
            } else {
              attackButton.style.backgroundColor = "#888888"; // Gray for miss
              setTimeout(() => {
                if (!currentPlayer.isDead) {
                  // Only revert color if not dead
                  attackButton.style.backgroundColor = "#ff4444";
                }
              }, 300);
            }
          });
        } else {
          console.error("Attack button not found after creation.");
        }
      }

      function initializeLocalPlayers(playersFromServer) {
        const localPlayers = [];
        const initialHealth = 20; // Define starting health

        // For each player from server data, create a local representation
        playersFromServer.forEach((player) => {
          const isSelf = player.id === playerId;
          const playerData = {
            id: player.id,
            name: player.name,
            isSelf: isSelf,
            isDead: player.isDead || false, // Ensure isDead exists
            health: player.isDead ? 0 : initialHealth, // Set initial health
            position: null, // Will be set for others
            mesh: null, // Will hold the THREE.js mesh
          };

          if (!isSelf) {
            // For other players, create default positions around the player in a circle
            const angle = Math.random() * Math.PI * 2;
            const distance = 1 + Math.random() * 0.5; // 1-1.5 meters away
            playerData.position = {
              x: Math.cos(angle) * distance,
              y: 0, // Same height as player (relative to AR space)
              z: Math.sin(angle) * distance,
            };
            // Create visual representation and store the mesh
            playerData.mesh = createPlayerVisual(
              player.id,
              player.name,
              playerData.position
            );
            if (playerData.isDead) {
              updatePlayerVisualForDeath(player.id, playerData.mesh); // Update visual if already dead
            }
          }
          localPlayers.push(playerData);
        });

        // Update the global game state
        window.gameState.localPlayers = localPlayers;
      }

      function createPlayerVisual(pId, playerName, position) {
        // Create a visual representation for this player
        const playerGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.25, 16); // Simpler geometry
        const playerMaterial = new THREE.MeshStandardMaterial({
          color: 0x0088ff,
        });
        const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);

        // Position the player based on the calculated relative position
        playerMesh.position.set(position.x, position.y, position.z);

        // Store player ID in userData for easy identification
        playerMesh.userData = { playerId: pId, playerName: playerName };

        scene.add(playerMesh);
        return playerMesh; // Return the mesh so it can be stored
      }

      function updatePlayerVisualForDeath(pId, playerMesh = null) {
        // Find the mesh if not provided
        if (!playerMesh) {
          const playerState = window.gameState.localPlayers.find(
            (p) => p.id === pId
          );
          if (playerState) {
            playerMesh = playerState.mesh;
          }
        }

        if (playerMesh && playerMesh.material) {
          // Gray out the player and add visual indicator
          playerMesh.material.color.set(0x888888);
          playerMesh.scale.y = 0.2; // Flatten the cylinder to indicate death
          playerMesh.position.y -= 0.1; // Lower slightly
        } else {
          console.warn(`Could not find mesh to update visual for player ${pId}`);
        }
      }

      // Handle when a player attacks the dragon
      socket.on("playerAttacked", (data) => {
        // Only process if game is active and gameState is initialized
        if (!window.gameState || !window.gameState.gameActive) return;

        const { playerId: attackingPlayerId, hit } = data;

        // Skip if it's our own attack (we've already shown feedback locally)
        if (attackingPlayerId === playerId) return;

        // Find the attacking player in local array
        const attackingPlayer = window.gameState.localPlayers.find(
          (p) => p.id === attackingPlayerId
        );

        if (!attackingPlayer || attackingPlayer.isDead) return; // Attacker not found or is dead

        // Get dragon position from localStorage (relative to the *current* player)
        const dragonPositionString = localStorage.getItem(
          `dragon_position_${gameId}_${playerId}`
        );
        if (!dragonPositionString) {
          console.warn("Dragon position not found in localStorage for laser effect.");
          return;
        }

        try {
          const dragonPosition = JSON.parse(dragonPositionString);

          // Create a laser effect (red line) from player to dragon
          createLaserEffect(attackingPlayer, dragonPosition, hit);

          // If the attack hit, reduce dragon health (locally for immediate feedback) and show visual feedback
          if (hit) {
            // Reduce local boss health state (server is the source of truth, but this gives immediate feedback)
            // Note: Server's 'bossHealthUpdated' event will correct this if needed.
            // window.gameState.bossHealth = Math.max(0, window.gameState.bossHealth - 10); // Example damage

            // Update UI if necessary (optional, as bossHealthUpdated handles it)
            // const gameInfoElement = document.getElementById('gameInfo');
            // if (gameInfoElement) {
            //   gameInfoElement.textContent = `Game Active! Boss Health: ${window.gameState.bossHealth}`;
            // }

            // Add visual hit effect on dragon
            showDragonHitEffect(dragonPosition);
          }
        } catch (e) {
          console.error("Error processing playerAttacked event:", e);
        }
      });

      // Helper function to create a laser effect
      function createLaserEffect(attackingPlayer, dragonPosition, hit) {
        // Get the position of the attacking player's mesh
        let startPosition;
        if (attackingPlayer.mesh) {
          startPosition = attackingPlayer.mesh.position.clone();
        } else if (attackingPlayer.position) {
          // Fallback to stored position if mesh isn't available (shouldn't happen often)
          startPosition = new THREE.Vector3(
            attackingPlayer.position.x,
            attackingPlayer.position.y,
            attackingPlayer.position.z
          );
        } else {
          console.warn(
            `Could not determine start position for laser from player ${attackingPlayer.id}`
          );
          return; // Cannot draw laser without start position
        }

        // Create end position for the dragon (using the position relative to the current player)
        const endPosition = new THREE.Vector3(
          dragonPosition.x,
          dragonPosition.y,
          dragonPosition.z
        );

        // Create laser geometry (a line from player to dragon)
        const laserGeometry = new THREE.BufferGeometry().setFromPoints([
          startPosition,
          endPosition,
        ]);

        // Choose laser color based on hit (red for miss, bright red/orange for hit)
        const laserColor = hit ? 0xff4500 : 0xff0000;
        const laserMaterial = new THREE.LineBasicMaterial({
          color: laserColor,
          linewidth: 3, // Note: linewidth might not be supported on all systems/drivers
          transparent: true,
          opacity: 0.8,
        });

        // Create the laser line
        const laser = new THREE.Line(laserGeometry, laserMaterial);
        scene.add(laser);

        // Add glow effect for hits
        if (hit) {
          // Create a point light at the dragon position to simulate impact
          const impactLight = new THREE.PointLight(0xff4500, 2, 1);
          impactLight.position.copy(endPosition);
          scene.add(impactLight);

          // Remove the impact light after a short time
          setTimeout(() => {
            scene.remove(impactLight);
          }, 200);
        }

        // Remove the laser after a short duration
        setTimeout(() => {
          scene.remove(laser);
        }, 300);
      }

      // Helper function to show a visual effect when the dragon is hit
      function showDragonHitEffect(dragonPosition) {
        if (!dragonPosition) {
          console.warn("Cannot show hit effect without dragon position.");
          return;
        }

        // Create hit effect (particles or explosion)
        const particles = new THREE.Group();
        const particleCount = 10;
        const particleColor = 0xff4500; // Orange/red

        // Create small spheres for particle effect
        for (let i = 0; i < particleCount; i++) {
          const particleGeometry = new THREE.SphereGeometry(0.02, 8, 8);
          const particleMaterial = new THREE.MeshBasicMaterial({
            color: particleColor,
            transparent: true,
            opacity: 0.9,
          });

          const particle = new THREE.Mesh(particleGeometry, particleMaterial);

          // Position particles around the dragon's stored position
          particle.position.set(
            dragonPosition.x + (Math.random() - 0.5) * 0.2,
            dragonPosition.y + (Math.random() - 0.5) * 0.2,
            dragonPosition.z + (Math.random() - 0.5) * 0.2
          );

          // Random velocity for outward burst
          const speed = 0.005 + Math.random() * 0.005;
          particle.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * speed,
            (Math.random() - 0.5) * speed,
            (Math.random() - 0.5) * speed
          );

          particles.add(particle);
        }

        scene.add(particles);

        // Animation for particles
        let frameCount = 0;
        const maxFrames = 30; // Duration of the effect

        function animateParticles() {
          if (frameCount >= maxFrames || !scene.getObjectById(particles.id)) {
            // Stop if max frames reached or particles removed
            if (scene.getObjectById(particles.id)) {
              scene.remove(particles);
            }
            return;
          }

          // Move particles outward and fade them
          particles.children.forEach((particle) => {
            if (particle.userData.velocity) {
              particle.position.add(particle.userData.velocity);
            }
            if (particle.material) {
              particle.material.opacity -= 1.0 / maxFrames; // Fade out linearly
            }
            particle.scale.multiplyScalar(0.97); // Shrink slightly
          });

          frameCount++;
          requestAnimationFrame(animateParticles);
        }

        animateParticles();

        // Add screen shake effect for hit feedback (optional, can be jarring)
        /*
      const originalCameraPosition = camera.position.clone();
      let shakeIntensity = 0.01; // Reduced intensity
      let shakeCount = 0;
      const maxShakes = 4;

      function shakeCamera() {
        if (shakeCount >= maxShakes || !renderer.xr.isPresenting) {
          // Don't reset position if not shaking or not in AR
          return;
        }

        // Apply random offset relative to current camera pose
        const session = renderer.xr.getSession();
        if (session) {
          session.requestAnimationFrame((time, frame) => {
            const viewerPose = frame.getViewerPose(renderer.xr.getReferenceSpace());
            if (viewerPose) {
              // This is complex in WebXR as camera position is controlled by tracking.
              // A better approach might be a visual overlay flash or vignette.
              // For simplicity, we'll skip direct camera manipulation in AR.
            }
          });
        }

        shakeCount++;
        shakeIntensity *= 0.9; // Reduce intensity over time
        setTimeout(shakeCamera, 50);
      }
      // shakeCamera(); // Uncomment carefully, test thoroughly in AR
      */
      }

      function showGameEndUI(data) {
        // Remove existing game UI first
        const existingGameUI = document.getElementById("gameUI");
        if (existingGameUI) existingGameUI.remove();
        const existingGameOverUI = document.getElementById("gameOverUI");
        if (existingGameOverUI) existingGameOverUI.remove();


        const gameOverUI = document.createElement("div");
        gameOverUI.id = "gameOverUI"; // Add an ID for potential removal
        gameOverUI.style.position = "fixed";
        gameOverUI.style.top = "50%";
        gameOverUI.style.left = "50%";
        gameOverUI.style.transform = "translate(-50%, -50%)";
        gameOverUI.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
        gameOverUI.style.color = "white";
        gameOverUI.style.padding = "30px";
        gameOverUI.style.borderRadius = "15px";
        gameOverUI.style.textAlign = "center";
        gameOverUI.style.zIndex = "1000";
        gameOverUI.style.pointerEvents = "auto"; // Allow interaction

        gameOverUI.innerHTML = `
        <h2>${data.playersWin ? "VICTORY!" : "DEFEAT!"}</h2>
        <p>${
          data.playersWin
            ? "The dragon has been defeated!"
            : "The dragon was too powerful!"
        }</p>
        <p>Final boss health: ${data.bossHealth}</p>
        <button id="returnToLobby" style="padding: 10px 20px; margin-top: 20px; background-color: #4285f4;
                color: white; border: none; border-radius: 5px; cursor: pointer;">
          Return to Lobby
        </button>
      `;

        document.body.appendChild(gameOverUI);

        document
          .getElementById("returnToLobby")
          .addEventListener("click", () => {
            // Optionally end the AR session before navigating
            const session = renderer.xr.getSession();
            if (session) {
              session.end().then(() => {
                window.location.href = "/game-lobby"; // Navigate after session ends
              });
            } else {
              window.location.href = "/game-lobby"; // Navigate directly if no session
            }
          });
      }

      // Animation loop
      function animate() {
        // Use renderer's animation loop for WebXR compatibility
        renderer.setAnimationLoop(() => {
          if (dragon) dragon.update(); // Update dragon animation if it exists
          renderer.render(scene, camera);
        });
      }

      // Start loading the dragon, then start the animation loop
      loadDragon()
        .then(() => {
          console.log("Dragon loaded, starting animation loop.");
          animate();
        })
        .catch((error) => {
          console.error("Error loading dragon:", error);
          // Handle error, maybe show a message to the user
          gameInfoElement.textContent = "Error loading dragon model!";
          gameInfoElement.style.backgroundColor = "rgba(255, 0, 0, 0.7)";
        });

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
