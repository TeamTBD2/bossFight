<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>AR with Three.js – Concept 1: Fixed Object Relative to Camera</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      /* Fullscreen video background */
      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: -1;
      }
    </style>
  </head>
  <body>
    <video id="video" autoplay playsinline muted></video>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Set up the video background from the rear camera
      const video = document.getElementById("video");
      navigator.mediaDevices
        .getUserMedia({ video: { facingMode: "environment" }, audio: false })
        .then((stream) => {
          video.srcObject = stream;
        })
        .catch((err) => console.error("Error accessing camera: ", err));

      // Create the Three.js scene and camera
      const scene = new THREE.Scene();
      // (We use a PerspectiveCamera even though we update its world position via geolocation.)
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      scene.add(camera);

      // Create the renderer with a transparent background so the video shows through
      const renderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create a red sphere geometry that will be attached to the camera.
      // By attaching it as a child of the camera at position (0, 0, -5),
      // it will always render 5 units in front of the camera.
      const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
      sphere.position.set(0, 0, -5);
      camera.add(sphere);

      // --- Geolocation Setup ---
      // We use the first geolocation reading as our "origin."
      let origin = null;
      let currentPosition = null;
      // A simple function to convert differences in latitude and longitude to approximate meters.
      // (1° latitude ~ 111320 m; longitude scaling is adjusted by the cosine of the latitude)
      function toMeters(latDiff, lonDiff, lat) {
        const metersPerLat = 111320;
        const metersPerLon = 111320 * Math.cos((lat * Math.PI) / 180);
        return { x: lonDiff * metersPerLon, z: latDiff * metersPerLat };
      }

      // Get the initial position (origin)
      navigator.geolocation.getCurrentPosition(
        (position) => {
          origin = {
            lat: position.coords.latitude,
            lon: position.coords.longitude,
          };
          currentPosition = origin;
        },
        (err) => {
          console.error("Error getting initial position", err);
        }
      );

      // Watch for position changes and update the camera’s world position accordingly.
      navigator.geolocation.watchPosition(
        (position) => {
          currentPosition = {
            lat: position.coords.latitude,
            lon: position.coords.longitude,
          };
          if (origin) {
            const latDiff = currentPosition.lat - origin.lat;
            const lonDiff = currentPosition.lon - origin.lon;
            const pos = toMeters(latDiff, lonDiff, origin.lat);
            // Update the camera’s position in the Three.js scene.
            // (Here we update the x and z coordinates; y could be updated if altitude data is available.)
            camera.position.set(pos.x, 0, pos.z);
          }
        },
        (err) => {
          console.error("Error watching position", err);
        }
      );

      // Render loop
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();

      // Adjust renderer size on window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
