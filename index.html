<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>AR with Three.js – Concept 2: Place Ball at Specific Location</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: -1;
      }
      #placeButton {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        padding: 10px 20px;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <video id="video" autoplay playsinline muted></video>
    <button id="placeButton">Place Ball Here</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Set up the video background
      const video = document.getElementById("video");
      navigator.mediaDevices
        .getUserMedia({ video: { facingMode: "environment" }, audio: false })
        .then((stream) => {
          video.srcObject = stream;
        })
        .catch((err) => console.error("Error accessing camera: ", err));

      // Create the Three.js scene and camera
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      scene.add(camera);

      const renderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // --- Geolocation Setup ---
      let origin = null;
      let currentPosition = null;
      function toMeters(latDiff, lonDiff, lat) {
        const metersPerLat = 111320;
        const metersPerLon = 111320 * Math.cos((lat * Math.PI) / 180);
        return { x: lonDiff * metersPerLon, z: latDiff * metersPerLat };
      }

      // Set the origin from the first geolocation reading.
      navigator.geolocation.getCurrentPosition(
        (position) => {
          origin = {
            lat: position.coords.latitude,
            lon: position.coords.longitude,
          };
          currentPosition = origin;
        },
        (err) => {
          console.error("Error getting initial position", err);
        }
      );

      // Update current position and the camera’s position.
      navigator.geolocation.watchPosition(
        (position) => {
          currentPosition = {
            lat: position.coords.latitude,
            lon: position.coords.longitude,
          };
          if (origin) {
            const latDiff = currentPosition.lat - origin.lat;
            const lonDiff = currentPosition.lon - origin.lon;
            const pos = toMeters(latDiff, lonDiff, origin.lat);
            camera.position.set(pos.x, 0, pos.z);
          }
        },
        (err) => {
          console.error("Error watching position", err);
        }
      );

      // When the user taps the button, place a blue ball at the current location.
      document.getElementById("placeButton").addEventListener("click", () => {
        if (!origin || !currentPosition) {
          alert("Waiting for geolocation…");
          return;
        }
        // Compute the ball’s position relative to the origin.
        const latDiff = currentPosition.lat - origin.lat;
        const lonDiff = currentPosition.lon - origin.lon;
        const pos = toMeters(latDiff, lonDiff, origin.lat);

        // Create the blue sphere (the ball) at that position.
        const ballGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const ballMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(pos.x, 0, pos.z);
        scene.add(ball);

        // Optionally hide the button after placing the ball.
        document.getElementById("placeButton").style.display = "none";
      });

      // Render loop
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
